//
//  ChatGPTService.swift
//  Flippin
//
//  Created by Alexander Riakhin on 10/11/25.
//

import Foundation
import OpenAI

@MainActor
final class ChatGPTService: ObservableObject {
    static let shared = ChatGPTService()
    
    @Published var isInitialized = false
    @Published var isGenerating = false
    
    private var openAI: OpenAI?
    private let remoteConfigService = RemoteConfigService.shared
    private let purchaseService = PurchaseService.shared
    private let userProfileService = UserProfileService.shared
    private let languageManager = LanguageManager.shared
    
    private init() {
        initializeClient()
    }
    
    // MARK: - Setup
    
    /// Initialize OpenAI client with API key from Firebase
    func initializeClient() {
        let apiKey = remoteConfigService.getChatGPTAPIKey()
        
        guard !apiKey.isEmpty else {
            print("⚠️ ChatGPT API key not configured")
            isInitialized = false
            return
        }
        
        let configuration = OpenAI.Configuration(token: apiKey, timeoutInterval: 60.0)
        openAI = OpenAI(configuration: configuration)
        isInitialized = true
        
        print("✅ ChatGPT service initialized")
    }
    
    // MARK: - Premium Check
    
    /// Check if user has premium access to AI features
    func isPremiumUser() -> Bool {
        return purchaseService.isProductPurchased("com.dor.flippin.premium_monthly") ||
               purchaseService.isProductPurchased("com.dor.flippin.premium_yearly")
    }
    
    /// Check if AI features can be used
    func canUseAIFeatures() -> Bool {
        guard remoteConfigService.isChatGPTEnabled() else {
            print("⚠️ ChatGPT features disabled in Remote Config")
            return false
        }
        
        guard isInitialized else {
            print("⚠️ ChatGPT service not initialized")
            return false
        }
        
        guard isPremiumUser() else {
            print("⚠️ User does not have premium subscription")
            return false
        }
        
        return true
    }
    
    // MARK: - Collection Generation
    
    /// Generate a custom flashcard collection based on user request
    func generateCollection(
        userRequest: String,
        targetLanguage: Language,
        cardCount: Int = 25
    ) async throws -> GeneratedCollection {
        guard canUseAIFeatures() else {
            throw ChatGPTError.premiumRequired
        }
        
        guard let openAI = openAI else {
            throw ChatGPTError.notInitialized
        }
        
        isGenerating = true
        defer { isGenerating = false }
        
        // Build context
        let userContext = getUserContext()
        let proficiency = userProfileService.currentProfile?.currentTargetLanguageProficiency?.displayName ?? "Beginner"
        let userLanguage = languageManager.userLanguage
        
        // Create system prompt
        let systemPrompt = """
        You are a language learning assistant creating flashcards for a student.
        
        Student Profile:
        \(userContext)
        
        Target Language: \(targetLanguage.displayName)
        Student's Native Language: \(userLanguage.displayName)
        Proficiency Level: \(proficiency)
        
        Instructions:
        - Create exactly \(cardCount) flashcards based on the request
        - frontText should be in \(targetLanguage.displayName)
        - backText should be in \(userLanguage.displayName) (translation)
        - notes should include usage tips or cultural context
        - tags should categorize the phrase (e.g., "travel", "food", "greetings")
        - difficulty should be 1-5, scaled to the student's proficiency level
        - Make cards practical and useful for the student's learning goals
        - Return ONLY valid JSON, no other text
        """
        
        // Create chat query with derived JSON schema
        let query = ChatQuery(
            messages: [
                .system(.init(content: .textContent(systemPrompt))),
                .user(.init(content: .string(userRequest)))
            ],
            model: .gpt4_o_mini,
            responseFormat: .jsonSchema(.init(
                name: "generated_collection",
                description: "A flashcard collection generated by AI",
                schema: .derivedJsonSchema(GeneratedCollection.self),
                strict: true
            ))
        )
        
        // Make API call
        let result = try await openAI.chats(query: query)
        
        guard let jsonString = result.choices.first?.message.content,
              let jsonData = jsonString.data(using: String.Encoding.utf8) else {
            throw ChatGPTError.invalidResponse
        }
        
        // Parse response
        let collection = try JSONDecoder().decode(GeneratedCollection.self, from: jsonData)
        
        // Log token usage
        if let usage = result.usage {
            print("📊 ChatGPT tokens used: \(usage.totalTokens) (prompt: \(usage.promptTokens), completion: \(usage.completionTokens))")
        }
        
        print("✅ Generated collection: \(collection.collectionName) with \(collection.cards.count) cards")
        
        return collection
    }
    
    // MARK: - Learning Coach
    
    /// Generate personalized learning insights based on analytics
    func generateWeeklyCoachInsights(
        analyticsData: AnalyticsDataSnapshot
    ) async throws -> CoachInsight {
        guard canUseAIFeatures() else {
            throw ChatGPTError.premiumRequired
        }
        
        guard let openAI = openAI else {
            throw ChatGPTError.notInitialized
        }
        
        isGenerating = true
        defer { isGenerating = false }
        
        // Build context
        let userContext = getUserContext()
        
        // Create system prompt
        let systemPrompt = """
        You are an encouraging language learning coach analyzing student performance.
        
        Student Profile:
        \(userContext)
        
        Study Performance This Week:
        - Accuracy: \(String(format: "%.1f%%", analyticsData.weeklyAccuracy * 100))
        - Cards Reviewed: \(analyticsData.cardsReviewed)
        - Study Days: \(analyticsData.studyConsistency) / 7
        - Average Time per Card: \(String(format: "%.1f", analyticsData.averageTimePerCard))s
        - Current Streak: \(analyticsData.streakDays) days
        - Total Cards: \(analyticsData.totalCards)
        - Mastered Cards: \(analyticsData.masteredCards)
        
        Difficult Cards (struggling with):
        \(analyticsData.difficultCards.prefix(5).joined(separator: ", "))
        
        Instructions:
        - Provide a motivating title and summary
        - Generate exactly 3 insights (positive, constructive, or actionable)
        - Each insight needs: icon (SF Symbol name), text, type ("positive"/"warning"/"neutral")
        - Generate exactly 3 recommendations with action, description, priority (1-3)
        - Be specific, data-driven, and encouraging
        - Return ONLY valid JSON, no other text
        """
        
        // Create chat query with derived JSON schema
        let query = ChatQuery(
            messages: [
                .system(.init(content: .textContent(systemPrompt))),
                .user(.init(content: .string("Analyze my learning progress and provide insights")))
            ],
            model: .gpt4_o_mini,
            responseFormat: .jsonSchema(.init(
                name: "coach_insight",
                description: "AI learning coach insights and recommendations",
                schema: .derivedJsonSchema(CoachInsight.self),
                strict: true
            ))
        )
        
        let result = try await openAI.chats(query: query)
        
        guard let jsonString = result.choices.first?.message.content,
              let jsonData = jsonString.data(using: String.Encoding.utf8) else {
            throw ChatGPTError.invalidResponse
        }
        
        let insight = try JSONDecoder().decode(CoachInsight.self, from: jsonData)
        
        if let usage = result.usage {
            print("📊 ChatGPT tokens used: \(usage.totalTokens)")
        }
        
        print("✅ Generated coach insight: \(insight.title)")
        
        return insight
    }
    
    // MARK: - Helper Methods
    
    /// Generate user context string from profile
    private func getUserContext() -> String {
        if let profile = userProfileService.currentProfile {
            return profile.generateChatGPTContext()
        }
        return "User Profile: Not available"
    }
}

// MARK: - ChatGPT Errors

enum ChatGPTError: LocalizedError {
    case notInitialized
    case premiumRequired
    case featureDisabled
    case invalidResponse
    case apiError(String)
    case networkError
    
    var errorDescription: String? {
        switch self {
        case .notInitialized:
            return "ChatGPT service is not ready. Please try again later."
        case .premiumRequired:
            return "AI features are available with Premium subscription"
        case .featureDisabled:
            return "AI features are temporarily unavailable"
        case .invalidResponse:
            return "Received invalid response from AI. Please try again."
        case .apiError(let message):
            return "AI Error: \(message)"
        case .networkError:
            return "Network connection failed. Check your internet and try again."
        }
    }
}

